\documentclass[11pt]{article}

\usepackage[english]{babel}
\usepackage{times}
\usepackage[cm]{fullpage}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage{makecell}
\usepackage{xspace}
\usepackage{color}
\usepackage{etoolbox}
\usepackage[]{longtable}
\usepackage{alltt}
\usepackage{multirow}
\usepackage[bottom]{footmisc}

\addto{\captionsenglish}{\renewcommand{\abstractname}{\vspace{-2\baselineskip}}}

%%%%%% FONTS %%%%%%
\usepackage{fontspec}
\usepackage{unicode-math}

\setmainfont{STIXGeneral}[
  Extension = .otf ,
  Path = stix/ ,
  UprightFont = *-Regular ,
  BoldFont = *-Bold ,
  ItalicFont = *-Italic ,
  BoldItalicFont = *-BoldItalic ,
]
\setsansfont{calibri}[
  Extension = .ttf ,
  Path = calibri/ ,
  BoldFont = *b ,
  ItalicFont = *i ,
  BoldItalicFont = *z ,
]
\setmonofont{DroidSansMono}[
  Extension = .ttf ,
  Path = droid/ ,
  Scale=MatchLowercase ,
]
\setmathfont{STIX Math}

%%%%%% COMMANDS %%%%%%

\newcommand\todo[1]{\textcolor{red}{TODO: #1}}

\newcommand{\varstyle}[1]{\notblank{#1}{\textsf{$<$#1$>$}}{}}
\newcommand{\rul}[2]{\varstyle{#1} $\rightarrow$ #2}

\newcommand\imp{\textsc{Imp}\xspace}
\newcommand\inttt{\texttt{int32}\xspace}

\title{Introduction to language theory and compiling \\ Project -- Part 3}
\author{Antoine Passemiers -- Alexis Reynouard}

\pagestyle{plain}
\setcounter{tocdepth}{2}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em plus0.5em minus0.3em}

\begin{document}
\pagenumbering{Roman}
\maketitle
\thispagestyle{empty}

\vfil
\begin{abstract}
In this work, we implemented an actual compiler for the \imp language.

Given the unambiguous LL(1) grammar (see previous report on how to produce it and how the program may help) for the imp
language and a source file, the compiler produces an LLVM-assambly language (LLVM IR) \texttt{.ll} file which may be
compiled to LLVM bitcode with the LLVM assembler \textsf{llvm-as(1)}.
So we extended the previously given \imp grammar to handle some new features
and made improvements to the lexer and parser.

We will begin with some choices we did to implement the compiler.
Second we will introduces the new additional features of the language.
Finally, we will present the new enriched \imp grammar,
then the actual code generator and the additions to the implementation of the lexer and parser.
\end{abstract}

\clearpage
\vfill
\hrule
\vspace{\baselineskip}
\tableofcontents
\vspace{3\baselineskip}
\hrule
\vfill
\clearpage

\setcounter{page}{1}
\pagenumbering{arabic}

\section{Assumptions, limitations and implementation choices}

First it worth noting that there exists two scopes in \imp.
The global scope outside any function and the local scope inside the functions.

The \imp variables are translated into named LLVM IR variables.
The temporary variables needed are implemented as unnamed LLVM IR variables.

The \imp language only support the \inttt type.
Any expressions which have a value have a \inttt value.
Notably, any functions which does not explicitly return a value returns 0.

The usage may seems strange because we have to give to the compiler the grammar of the \imp language.
This is because we implemented modular lexer and parser, but the code generation was hard-coded due to a lack of time.
If the code generator detect an inconsistency due to the usage of another grammar, an error message will be displayed
and the program exit with the error code -1.

\section[The enriched \imp language]{The enriched \imp language (bonus features)}

Here we present briefly the additions made to the \imp language. For a more precise description the reader can go to the
next section.

\subsection{Randomness}

The ability to use pseudo random numbers was added to the language through the \texttt{rand} keyword.
The expression \texttt{rand(a)} assigns a pseudo random value between \todo{min} and \todo{max} to the variable \texttt{a}.

\subsection{Functions}

Informally, an \imp function is an executable statement, composed of any instruction list without \texttt{define} and
\texttt{import}, and whose the value is an \inttt.

A function must be defined before any usage.
The way to define a function is described by the variable \varstyle{Define} of the language.
A usage of, or ``call to'', the function is defined by the \varstyle{Call} variable.
The arguments are passed to the function by copy and the inner variable are defined in a local scope.

To take an example, the following program print 12:\\
\texttt{
  \input{../../../test/test-18.imp}
}

Because a function has to be defined before its first call, recursive calls are not supported.

Unfortunately for now the compiler is not able to detect that a function call respect the function signature, this can
lead to an error when running the llvm assembler \textsf{llvm-as}, like
\begin{verbatim}
llvm-as: main.ll:85:19: error: '@foo' defined with type 'i32 (i32*, i32*)*'
    %2 = call i32 @foo(i32* %c0c0)
\end{verbatim}
Here for example, the function was defined with two parameters but called with only one argument.

\subsection{Import}

One can create a file to contains code for later use in other files.
Once created any file may be imported in another thanks to the \texttt{import} keyword.
\todo{}

A file designed to be \texttt{import}ed into other files is called a module.

\subsection{The standard library}

The standard library provide three modules. Two of them, \texttt{\todo{}} and \texttt{\todo{}} are imported by default.
They provide some functions whose the name is self-explanatory: \texttt{\todo{}}

The last one may be included with \texttt{\todo{}} and provide the \texttt{\todo{}} and \texttt{\todo{}} functions.

\section{Augmenting \imp's syntax and grammar}

\subsection{Regular expressions}

The lexer was extended to read the new keywords:
\texttt{rand}, \texttt{function}, \texttt{return}, \texttt{import}, \texttt{,} (comma),
as well as two new ``kinds of identifier'': \textsf{FuncName} and \textsf{ModuleName}
which are respectively identifiers for functions (begins with a ``@'')
and identifiers for modules (begins with a ``\_'').

\begin{center}{\sffamily
\begin{tabular}{l @{ = } l}
  Identifier     & \{Alpha\}\{AlphaNumeric\}* \\
  FuncName       & @\{Identifier\} \\
  ModuleName     & \_\{Identifier\} \\
\end{tabular}
}\end{center}

\subsection{Grammar rules}

Here is the new grammar for the \imp language.
\todo{The main additions and changes are marked with an asterisk (\textsf{*}).}

One can note four main changes:
\begin{itemize}
  \item \varstyle{Instruction} is divided into \varstyle{Instruction} and \varstyle{FuncInstruction} (and some other
    variables were updated to reflect this change). \varstyle{FuncInstruction} is defined as an \varstyle{Instruction}
    without \varstyle{Define} and \varstyle{Import}.
  \item \varstyle{ParamList} was introduced to define functions (with \varstyle{Define}),
  \item \varstyle{ArgList} was introduced to call functions (with \varstyle{Call}),
  \item \varstyle{Assign} was modified to allow to assign a variable with the result of a function call.
\end{itemize}


\newcounter{Rule}
\newsavebox{\varbox}
\begin{longtable}{
    >{}r<{\sffamily[\stepcounter{Rule}\theRule]}
    l
    @{ $\rightarrow$ } >{\ttfamily}l<{\ttfamily}
  }
  \input{../../../more/grammars/imp_ll.grammar.tex}
\end{longtable}

\section{Implementation}

\subsection{Improvements in both lexer and parser}

To read the new keywords, the lexer was enriched with the corresponding lexical units: \texttt{RAND}, \texttt{FUNCTION},
\texttt{FUNCNAME}, \texttt{RETURN}, \texttt{IMPORT}, \texttt{MODULENAME} and \texttt{COMMA}.

The parser receive the corresponding improvement as well as some modifications, especially to display errors in a more
convenient way.

The error management was improved as described in a following section.

\subsection{LLVM code generator}

For each variable of the grammar, a method to produce the corresponding llvm code is hard-coded.
When needed, such a method return the number of an unnamed variable used to store the result of the code generated.
For example, when working on \texttt{a := 7 + 9}, 7 and 9 are both stored in an unnamed llvm variable. Which one is
defined and returned by the function which generate the corresponding code (\texttt{generateFromAtom}).
Then, the result of the addition is stored in an unnamed variable too (\texttt{generateFromExprArithP0J}).

\subsection{Error handling}

The compiler may report some errors due to an input which does not correspond to the given grammar, or which may not
produce some valid code (call to an undefined function).
Sometimes the compiler may detect an error in the grammar (see the previous report).

Errors in the source file are detected by one of the compiler component, according to the kind of error.

\paragraph*{The Lexer} may report an error (\texttt{BadTerminalException}) when a terminal can not be associated to a
lexical unit, or sometimes when a terminal is encountered in a bad context (\texttt{BadTerminalContextException}) (see
the first report).

\paragraph*{The parser} report errors either when the read token does not give any action in the action table
according to the current top of stack (\texttt{UnexpectedSymbolException}),
or when the end of file is encountered before the end of the program (\texttt{UnexpectedEndOfFileException}).
% Note that the display of these errors was improved to be more easily fixable.

\paragraph*{The code generator} report an error if one try to call an undefined function
(\texttt{UndefinedFunctionException}).
Note that there is no declaration required in \imp for (\inttt) variables.
So all the variables are implicitly declared at the beginning of the program, but not assigned.
It is the responsibility of the programmer to ensure that a value is assigned to the variable before use,
otherwise the behaviour of the program may be unexpected.

\paragraph*{Returned error codes}

On success, the compiler return 0 (or the success value of the platform).
Otherwise, the return value depends on the error.
These values are shown in the table below:

\begin{center}
  \begin{tabular}{| l | l | l |}
    \hline
    Error from & code & description \\ \hline
    \multirow{2}{*}{OS} & 1 & IO error \\
    & 2 & File not found \\ \hline
    \multirow{2}{*}{Lexer} & 16 & Unkown terminal \\
    & 17 & Bad terminal context \\ \hline
    \multirow{2}{*}{Parser} & \multirow{2}{*}{19} & Unexpected symbol \\
    & & Unexpected end of file \\ \hline
    Code generator & 18 & Call to undefined function \\ \hline
    & -1 & Unknown \\
    & -1 & Not imp grammar\footnotemark[1]
    \\ \hline
  \end{tabular}
  \footnotetext[1]{Temporary error because of the modular lexer and parser (work well with any ll(1)
  grammar whose keywords and lexical units are the same as the current \imp language)
  working with a currently not modular code generator (the \imp grammar is hard-coded).}
\end{center}

\paragraph*{Here is an example}
of error reported by the parser when one try to define a function inside another function:

\begin{verbatim}
Unexpected symbol:
'function' with TOS: '<FuncInstList>'
LL1Parser:
    token number: 35
    stack: [ '<FuncInstList>', 'end', '<InstList-Tail>', 'end', '$' ]
    token: function     lexical unit: FUNCTION
    line: 5, column: 1
    code: + 1 ; function @bar ( b 
\end{verbatim}

\end{document}

% vim: set spell spelllang=en :
