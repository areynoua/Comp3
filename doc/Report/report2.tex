\documentclass[12pt]{report}

\usepackage[english]{babel}
\usepackage{times}
\usepackage{fullpage}
\usepackage[bottom]{footmisc}
\usepackage{chngcntr}
\usepackage{etoolbox}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{geometry}
\usepackage{calrsfs}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage{titlesec}
\usepackage{amssymb} 
\usepackage{makecell}
\usepackage{color}
\usepackage{enumerate}
\usepackage{array}

\newcommand\todo[1]{\textcolor{red}{TODO: #1}}

\titleformat{\chapter}{\normalfont\huge}{\thechapter.}{20pt}{\huge}

\title{Introduction to language theory and compiling \\ Project -- Part 2}
\author{Antoine Passemiers \\ Alexis Reynouard}

\pagestyle{plain}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em plus0.5em minus0.3em}

\pagenumbering{Roman}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
\setcounter{chapter}{0}
\pagenumbering{arabic}

%FIXME: does not print <> if #1 empty
\newcommand{\varstyle}[1]{\notblank{#1}{\textsf{$<$#1$>$}}{}}

\begin{document}
\maketitle
\tableofcontents
\thispagestyle{empty}
\pagebreak
\setcounter{page}{1}
\clearpage

\chapter{Transforming Imp grammar}

This part of the project consists in implementing a $LL(k)$ parser for the Imp programming language. A $LL(k)$ parser is a recursive descent parser composed of:

\begin{itemize}
\item An input buffer, containing $k$ input tokens. Since we are considering a $LL(1)$ parser, the latter only considers one token at a time to decide how to 
grow the syntactic tree.
\item A stack containing the set of remaining terminals and non-terminals to process.
\item An action table, mapping the front of the stack and the current token to the corresponding rule.
\end{itemize}

\section{Removing useless rules and variables}

\subsection{Unreachable variables}

Unreachable variables are variables that cannot be accessed using composed rules from grammar $G$.

\begin{tabular}{|l p{35em}|} \hline
 i & $V_i$ \\ \hline
0 & $\{Program\}$ \\ \hline
1 & $V_0 \cup \{Code\}$ \\ \hline
2 & $V_1 \cup \{IntList\}$ \\ \hline
3 & $V_2 \cup \{Instruction\}$ \\ \hline
4 & $V_3 \cup \{Assign, If, While, For, Print, Read\}$ \\ \hline
5 & $V_4 \cup \{ExprArithm, Cond\}$ \\ \hline
6 & $V_5 \cup \{Op, BinOp, SimpleCond\}$ \\ \hline
7 & $V_6 \cup \{Comp\}$ \\ \hline
8 & $V_7$ \\ \hline
\end{tabular}

All variables are accessible.

\subsection{Unproductive variables}

\begin{tabular}{|l p{35em}|} \hline
 i & $V_i$ \\ \hline
0 & $\phi$ \\ \hline
1 & $\{Code, ExprArithm, Op, BinOp, Comp, Print, Read\}$ \\ \hline
2 & $V_1 \cup \{Program, Instruction, Assign, For, SimpleCond\}$ \\ \hline
3 & $V_2 \cup \{IntList, Cond\}$ \\ \hline
4 & $V_3 \cup \{While, If\}$ \\ \hline
5 & $V_4$ \\ \hline
\end{tabular}

All variables are productive.

\section{Removing ambiguity}

\subsection{Operator priority}

\begin{tabular}{lll}
  \varstyle{CondP1} & $\rightarrow$ & \varstyle{CondP1} and \varstyle{CondP2} \\
  & $\rightarrow$ & \varstyle{CondP2} \\
  \varstyle{CondP2} & $\rightarrow$ & \varstyle{CondP2} or \varstyle{CondP3} \\
  & $\rightarrow$ & \varstyle{CondP3} \\
  \varstyle{CondP3} & $\rightarrow$ & not \varstyle{SimpleCond} \\
  & $\rightarrow$ & \varstyle{SimpleCond} \\
\end{tabular}

\begin{tabular}{lll}
  \varstyle{Assign} & $\rightarrow$ & [VarName] := \varstyle{ExprArithP1} \\
  \varstyle{SimpleCond} & $\rightarrow$ & \varstyle{ExprArithmP1} \varstyle{Comp} \varstyle{ExprArithP1} \\
  &  $\rightarrow$ & TODO ??? \\
  \varstyle{ExprArithP1} & $\rightarrow$ & \varstyle{ExprArithP1} + \varstyle{ExprArithP2} \\
  & $\rightarrow$ & \varstyle{ExprArithP1} - \varstyle{ExprArithP2} \\
  & $\rightarrow$ & \varstyle{ExprArithP2} \\
  \varstyle{ExprArithP2} & $\rightarrow$ & \varstyle{ExprArithP2} * \varstyle{ExprArithP3} \\
  & $\rightarrow$ & \varstyle{ExprArithP2} / \varstyle{ExprArithP3} \\
  & $\rightarrow$ & \varstyle{ExprArithP3} \\
  \varstyle{ExprArithP3} & $\rightarrow$ & [VarName] \\
  & $\rightarrow$ & [number] \\
  & $\rightarrow$ & ( \varstyle{ExprArithP3} ) \\
  & $\rightarrow$ & - \varstyle{ExprArithP3} \\
\end{tabular}

\subsection{Operator associativity}

\section{Removing left-recursion and applying factorization}

\subsection{Left-recursion}

\subsection{Factorization}

\begin{tabular}{lll}
  \varstyle{If} & $\rightarrow$ & if \varstyle{Cond} then \varstyle{Code} \varstyle{IfTail} \\
  \varstyle{IfTail} & $\rightarrow$ & endif \\
  & $\rightarrow$ & else \varstyle{Code} endif \\
  \varstyle{For} & $\rightarrow$ & for [VarName] from \varstyle{ExprArith} \varstyle{ForTail} \\
  \varstyle{ForTail} & $\rightarrow$ & \varstyle{ExprArith} to \varstyle{ExprArith} do \varstyle{Code} done \\
  & $\rightarrow$ & \varstyle{ExprArith} do \varstyle{Code} done \\
\end{tabular}

\section{Resulting grammar}

\newcounter{Rule}
\newsavebox{\varbox}
\begin{tabular}{
    >{\sffamily[\stepcounter{Rule}\theRule}r<{]}
    >{\begin{lrbox}{\varbox}\sffamily}l<{\end{lrbox}\varstyle{\unhbox\varbox}}
    @{ $\rightarrow$ } >{\ttfamily}l<{\ttfamily}
  }
  & Program & begin \varstyle{Code} end \\
  & Code & $\epsilon$ \\
  & & \varstyle{InstList} \\
  & InstList & \varstyle{Instruction} \\
  & & \varstyle{Instruction} ; \varstyle{InstList} \\
  & Instruction & \varstyle{Assign} \\
  & & \varstyle{If} \\
  & & \varstyle{While} \\
  & & \varstyle{For} \\
  & & \varstyle{Print} \\
  & & \varstyle{Read} \\
  & Assign & [VarName] := \varstyle{ExprArithP1} \\
  & If & if \varstyle{Cond} then \varstyle{Code} \varstyle{IfTail} \\
  & IfTail & endif \\
  & & else \varstyle{Code} endif \\
  & For & for [VarName] from \varstyle{ExprArith} \varstyle{ForTail} \\
  & ForTail & \varstyle{ExprArith} to \varstyle{ExprArith} do \varstyle{Code} done \\
  & & \varstyle{ExprArith} do \varstyle{Code} done \\  
  & Comp & = \\
  & & >= \\
  & & > \\
  & & <= \\
  & & < \\
  & & <> \\
  & While & while \varstyle{Cond} do \varstyle{Code} done \\
  & Print & print ( [VarName] ) \\
  & Read & read ( [VarName] ) \\
\end{tabular}

\end{document}
