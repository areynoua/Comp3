\section{Implementation of the LL(1) parser}

\subsection{Theoretical considerations}

The objective is to implement a \textbf{top-down parser} that tells whether a word (sequence of tokens)
is part of the language (Imp grammar) or not. This parser begins with the start variable and builds the
tree in a depth-first fashion using \textbf{production rules}. More specifically, it consists of a pushdown
automaton (PDA) that accepts the language by empty stack. Let's define this PDA formally:

\begin{equation}
  \begin{split}
    P_{Imp} = (\{q\}, T, V \cup T, \delta, q, \$, \phi)
   \end{split}
\end{equation}

\begin{itemize}
  \item Because $P_{Imp}$ accepts the grammar \textbf{by empty stack} and not by accepting state, it only requires the initial state to work. 
        Let's call this state $q$. The set of states is thus \{q\}.
  \item The alphabet of the input buffer is $T$. The set of terminals $T$ is the set of \textbf{lexical units} of Imp grammar. 
        Each terminal represents a type of token.
  \item The alphabet of the stack corresponds to $T \cup V$. Indeed, the stack is supposed to contain both lexical units and variables
        at some point, since variables are mandatory to use production rules.
  \item The transition function $\delta$ is such that the PDA can either \textbf{produce} or \textbf{match}. This will be explained
        in more details later on.
  \item The start symbol is $q$.
  \item We use \$ as the first symbol to push on the stack. When the stack becomes empty, the input buffer must have only one token
        remaining, which is \$. If it is not the case, the word is rejected.
  \item The set of accepting states is empty since we are not accepting words by accepting states, but by empty stack.
\end{itemize}

\todo{Comment ca marche ?}

\subsection{Automating the process, but not too much}

Hard coding is bad. That is the reason why we did not described the grammar in the source code itself.
We encoded the Imp grammar (as it was presented in the project statement) in a dedicated \textit{more/grammars} folder and called \textit{imp.grammar}.
After that, we checked for useless rules and symbols (and found nothing) by hand but also programmatically, and finally dealed with
the operators priority and associativity by hand. The resulting grammar file, called \textit{imp\_prim.grammar} is used as input by our program.
We will refer to the later as the \textbf{unambiguous Imp grammar}.

We removed left-recursion, left-factored the grammar and finally computed first sets and follow sets of each grammar symbol by hand. 
Everything has been verified programmatically. When the parser is executed on an input Imp file, a lexer is instantiated to be able
to get the resulting list of tokens. Then this sequence of tokens is passed to the parser that first loads the unambiguous Imp grammar,
processes all the steps that we just enumerated \textbf{to make it LL(1)}, 
builds its action table from first sets and follow sets, and finally does the parsing itself.

\subsection{Grammar symbols and rules}

Because everything had to be implemented from scratch, we had to define what grammar symbols actually are. Because class \textit{Symbol}
was already present in our source code, and because it is (as explained earlier) fondamentally different from grammar symbols,
we created a new class \textit{GrammarSymbol}. A grammar symbol \textbf{can be either a variable or a terminal}. Everytime one does need
to know whether a grammar symbol is a terminal or not, he calls the method \textit{isTerminal}.

A \textit{Rule} is an object that consists of a left-hand variable represented by a \textit{GrammarSymbol} and a right-hand sequence
of symbols represented by a list of \textit{GrammarSymbol} objects. All rules are instantiated when loading the unambiguous grammar file.
For better productivity, we added special methods to display the rules, pretty print them or export them to LaTex.

\subsection{Action table}

Class \textit{ActionTable} has been implemented as a Map, where keys are pairs of \textit{GrammarSymbol} objects, and values are integers
that represent actions. Each key pair is composed of two parts: the symbol that is on top of the stack, and the next input terminal to read.
Integer values that are positive represent rule numbers, in particular the rule that must be used to produce. The
action table for the imp language is given below. Strictly negative integers
represent other types of actions: -1 stands for \textbf{match}, -2 stands for \textbf{accept} and -3 stands for \textbf{error}.


\subsection{LL(1) parser}

\subsection{How to use the parser}

\begin{lstlisting}
Arguments :
	(1) --ru <grammar file> -o <grammar output file>
	(2) --ll <grammar file> -o <grammar output file>
	(3) --at <ll1 unambiguous grammar file> -o <latex output file>
	(4) <ll1 unambiguous grammar file> <code> [-o <parse tree output file>]
(1) remove useless
(2) left factorization and removing of left recursion
(3) print action table
(4) save parse tree and output the rule used}
\end{lstlisting}

\todo{todo}
