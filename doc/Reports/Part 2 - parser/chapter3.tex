\chapter{Implementation of the LL(1) parser}

\section{Theoretical considerations}

The objective is to implement a \textbf{top-down parser} that tells whether a word (sequence of tokens)
is part of the language (Imp grammar) or not. This parser begins with the start variable and builds the
tree in a depth-first fashion using \textbf{production rules}. More specifically, it consists of a pushdown
automaton (PDA) that accepts the language by empty stack. Let's define this PDA formally:

\begin{equation}
  \begin{split}
    P_{Imp} = (\{q\}, T, V \cup T, \delta, q, \$, \phi)
   \end{split}
\end{equation}

\begin{itemize}
  \item Because $P_{Imp}$ accepts the grammar \textbf{by empty stack} and not by accepting state, it only requires the state to work. 
        Let's call this state $q$. The set of states is thus \{q\}.
  \item The alphabet of the input buffer is $T$. The set of terminals $T$ is the set of \textbf{lexical units} of Imp grammar. 
        Each terminal represents a type of token.
  \item The alphabet of the stack corresponds to $T \cup V$. Indeed, the stack is supposed to contain both lexical units and variables
        at some point, since variables are mandatory to use production rules.
  \item The transition function $\delta$ is such that the PDA can either \textbf{produce} or \textbf{match}. This will be explained
        in more details later on.
  \item The start symbol is $q$.
  \item We use \$ as the first symbol to push on the stack. When the stack becomes empty, the input buffer must have only one token
        remaining, which is \$. If it is not the case, the word is rejected.
  \item The set of accepting states is empty since we are not accepting words by accepting states, but by empty stack.
\end{itemize}

\todo{Comment ca marche ?}

\section{Automating the process, but not too much}

Hard coding is bad. That is the reason why we did not described the grammar in the source code itself.
We encoded the Imp grammar (as it was presented in the project statement) in a dedicated \textit{more/grammars} folder and called \textit{imp.grammar}.
After that, 

\section{Grammar symbols and rules}

Because everything had to be implemented from scratch, we had to define what grammar symbols actually are. Because class \textit{Symbol}
was already present in our source code, and because it is (as explained earlier) fondamentally different from grammar symbols,
we created a new class \textit{GrammarSymbol}. A grammar symbol \textbf{can be either a variable or a terminal}. Everytime one does need
to know whether a grammar symbol is a terminal or not, he calls the method \textit{isTerminal}.



\section{Pushdown automaton}

\section{LL(1) parser}

\section{How to use the parser}

Arguments : \\
\indent (1) [OPTIONS] --ru <grammar file> -o <grammar output file> \\
\indent (2) [OPTIONS] --ll <grammar file> -o <grammar output file> \\
\indent (3) [OPTIONS] --at <ll1 unambiguous grammar file> \\
\indent (4) [OPTIONS] <ll1 unambiguous grammar file> <code> -o <latex output file>