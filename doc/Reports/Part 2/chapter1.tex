\chapter{Transforming Imp grammar}

This part of the project consists in implementing a $LL(k)$ parser for the Imp programming language. A $LL(k)$ parser is a recursive descent parser composed of:

\begin{itemize}
\item An \textbf{input buffer}, containing $k$ input tokens. Since we are designing a $LL(1)$ parser only, the latter only considers one token at a time to decide how to grow the syntactic tree.
\item A \textbf{stack} containing the set of remaining terminals and non-terminals to process.
\item An \textbf{action table}, mapping the front of the stack and the current token to the corresponding rule. Every time a rule is retrieved from the action table, the top of the stack is replaced by the sequence of symbols to the right of the current rule.
\end{itemize}

One is not able to construct an action table if the given grammar is not $LL(1)$. For that purpose, we were asked to modify the grammar in such a way
that it becomes possible to determine the $first^1$ and $follow^1$ sets of each symbol of the grammar. More specifically,
we must remove useless variables, unproductive rules, take into account operators priority and associativity, remove left-recursion and finally left-factor the grammar.

The order in which one processes these steps in crucial: if one tries to add rules with respect to the operators priority, one may encounter problems due
to unproductive rules. In addition to that, the method we were suggested to use to deal with associativity and priority actually introduces new left-recursive
rules. That is the reason why the left-recursion removal must be applied after using this method.

\section{Remark about symbols}
In this report, we will refer to symbols as \textbf{grammar symbols} or simply \textbf{symbols}. To speak about symbols for the lexer, we will refer to it as \textbf{lexical symbols}. The distinction is crucial because the lexer and the parser are based on different types of automata.
The deterministic automaton (used by the lexer) can only process \textbf{characters} while the pushdown automaton (used by the parser) takes
\textbf{tokens as input}. A token is an instance of a lexical unit and consists in a sequence of characters. Plus, tokens are generated by the lexer and
used as input to the parser. By nature, they use \textbf{different alphabets}.

Also, we will refer to sequences of grammar symbols as \textbf{words}. They latter are different from lexical words, which represent tokens.


\section{Removing useless rules and symbols}

A \textbf{useless symbol} is a symbol that is either unproductive (terminals are productive by nature, so they are not considered when we talk about productivity) or unreachable. A \textbf{useless rule} can only be an unproductive rule, which means that it contains
unproductive variables. A variable is called unproductive if none of its derivations yields anything. An unreachable symbol is a symbol that cannot be derived
from the start grammar symbol. Let's summarize: a rule is useless if it is unproductive, a terminal is useless if it is unreachable, and a variable is useless if it is either unreachable or unproductive. This step of the project consists in removing those symbols and rules, when they are useless.

\subsection{Unreachable symbols}

Unreachable symbols are symbols that cannot be derived from the start variable. The start variable \varstyle{Program} is reachable by nature
because every sequence of input tokens is a program and this implies that it is the only variable to begin with. 
The property of a reachable variable $A$ is as follows: if there exists a rule of the form $A \rightarrow \alpha$, then all symbols in sequence $\alpha$
are reachable as well. By induction, we can infer that any symbol is reachable if:
\begin{equation}
  \begin{split}
    \varstyle{Program} \Rightarrow_{G}^{*} A \beta B, \text{ where } A, B \in (T \cup V)^{*} \text{ and } \beta \in (T \cup V)
   \end{split}
\end{equation}
where $G$ is the Imp grammar.

To remove the unreachable symbols, we first enumerate the reachable symbols using the following procedure:
\begin{itemize}
  \item Initialize the set of reachable symbols as the set containing only the start symbol \varstyle{Program}.
  \item Every time a rule of the form $A \rightarrow \alpha$ is found, where $A$ is a reachable variable, we add every symbol from sequence $\alpha$
  to the set of reachable symbols.
  \item We stop after we have explored all rules without discovering new reachable symbols.
\end{itemize}
This yields the following table:

\begin{tabular}{|l p{35em}|} \hline
   i & $V_i$ \\ \hline
  0 & $\{Program\}$ \\ \hline
  1 & $V_0 \cup \{Code\}$ \\ \hline
  2 & $V_1 \cup \{IntList\}$ \\ \hline
  3 & $V_2 \cup \{Instruction\}$ \\ \hline
  4 & $V_3 \cup \{Assign, If, While, For, Print, Read\}$ \\ \hline
  5 & $V_4 \cup \{ExprArithm, Cond\}$ \\ \hline
  6 & $V_5 \cup \{Op, BinOp, SimpleCond\}$ \\ \hline
  7 & $V_6 \cup \{Comp\}$ \\ \hline
  8 & $V_7$ \\ \hline
\end{tabular}

We observe that in the end the set of reachable symbols contains all the symbols of the grammar. As a result, \textbf{all symbols are reachable}.
To validate this result, we implemented the unreachable-symbol removal algorithm and got the same result.

\subsection{Unproductive variables}

A rule is productive if all symbols of its right-hand part are productive. Because terminals are always productive, we must only look for
productive variables. The intuition is that a variable is unproductive if none of its derivations yields anything. In other words, it is impossible to find a \textbf{finite} word such that it can be derived from this variable. Typically, this happens when the variable is recursive. For example:
\begin{equation}
  \begin{split}
    \varstyle{ExprArith-p1} \rightarrow \varstyle{ExprArth-p1} + \varstyle{ExprArith-p2}
   \end{split}
\end{equation}

This rule, \textbf{all by itself} (with no other rule including \varstyle{ExprArithmP1} as left-hand variable), is unproductive.
Indeed, the derivation requires an infinite number of steps to reach $ + $ \varstyle{ExprArithP2}, which results in an infinite word of variables.
To be productive, this word must be composed of \textbf{terminals}.
More formally, a productive rule $A \rightarrow \alpha$ must be such that its left-hand productive variable yields a finite sequence of terminals:
\begin{equation}
  \begin{split}
    A \Rightarrow_{G}^{*} w \text{ where } w \in T^{*}
  \end{split}
\end{equation}
where $G$ is the Imp grammar.

To remove unproductive rules, we had to remove unproductive variables first. The easiest way to proceed is to enumerate the productive variables.
We did it as follows:
\begin{itemize}
  \item Initialize the set of productive symbols as the set of terminals, because we know that terminals are productive by nature. Indeed, 
  a string composed of a \textbf{finite number of terminals} is finite itself.
  \item Every time a rule of the form $A \rightarrow \alpha$ is found, where $\alpha$ is a string composed of productive symbols, we add its left-hand 
  variable to the set of productive symbols. The reason is that a string composed of strings of terminals are also finite. Using an inductive reasoning, 
  one can notice that this intuition holds for as many recursion levels as needed.
  \item We stop after we have explored all rules without discovering new productive variables.
\end{itemize}
This yields the following table:

\begin{tabular}{|l p{35em}|} \hline
   i & $V_i$ \\ \hline
  0 & $T$ \\ \hline
  1 & $V_0 \cup \{Code, ExprArithm, Op, BinOp, Comp, Print, Read\}$ \\ \hline
  2 & $V_1 \cup \{Program, Instruction, Assign, For, SimpleCond\}$ \\ \hline
  3 & $V_2 \cup \{IntList, Cond\}$ \\ \hline
  4 & $V_3 \cup \{While, If\}$ \\ \hline
  5 & $V_4$ \\ \hline
\end{tabular}

At the end, we get that the set contains all grammar symbols. As consequence, \textbf{all symbols are productive}. To validate this result, we implemented
the unproductive-rule removal algorithm and got the same result.

\section{Removing ambiguities}

A grammar is ambiguous if one can draw at least two different derivation trees from a same input word, using the grammar rules.
The Imp grammar is ambiguous because of its logical and arithmetic operators. Let's replace ambiguous rules by new rules in such way
that is takes into account both operator associativity and operator priority.

\subsection{Operator priority}

Let's take the sequence of tokens $A + B * C$ as example. In any case, a top-down parser would apply rule 
\varstyle{ExprArith} $\rightarrow$ \varstyle{ExprArith} \varstyle{Op} \varstyle{ExprArith}. 
Because of the ambiguity of the grammar, the parser would not know which operator to apply next, it could use any of the two following rules:

\begin{tabular}{lll}
  \varstyle{Op} & $\rightarrow$ + \\
  & $\rightarrow$ * \\
\end{tabular}

Because operators * and / have a higher priority than operators + and -, the parser must consider expression $A + B * C$ as \textbf{the sum of two expressions} $A$ and $B * C$. Let's rename $A$ by \varstyle{ExprArith-p0} (where p0 stands for lowest priority 0), and $B * C$ by \varstyle{ExprArith-p1}.
We now get a new rule:

\begin{tabular}{lll}
\varstyle{ExprArith-p0} & $\rightarrow$ & \varstyle{ExprArith-p0} \varstyle{Op} \varstyle{ExprArith-p1}
\end{tabular}

where \varstyle{Op} can be any of the operators that have the same priority level as + (actually we only consider + and -). The problem of this technique is
that \textbf{it makes the assumption that the total expression contains an addition or a subtraction}. Let's add a rule to give the parser the opportunity
to skip these operations if it needs to:

\begin{tabular}{lll}
\varstyle{ExprArith-p0} & $\rightarrow$ & \varstyle{ExprArith-p1}
\end{tabular}

The grammar now takes into account the differences in priority between \{+, -\} and \{*, /\}, but not between \{*, /\} and operators () and unary minus.
Because unary minus has a higher priority than operators * and /, let's use the same method. This results in the following new rules:

\begin{tabular}{lll}
  \varstyle{ExprArith-p1} & $\rightarrow$ & \varstyle{ExprArith-p1} \varstyle{Op-p1} \varstyle{Atom} \\
  & $\rightarrow$ & \varstyle{Atom} \\
  \varstyle{Atom} & $\rightarrow$ & - \varstyle{Atom} \\
\end{tabular}

where \varstyle{Op-p1} can be any of the operators that have the same priority level as * (can be either * or /).

\subsubsection{The problem of parentheses}
The problem of parentheses is less trivial than the unary minus problem. Let's take $(A + B) * C$ as example. We must add a new rule such as
the () operator has the highest priority. To respect the priority order, this rule must be of the form \\ \varstyle{Atom} $\rightarrow \alpha$.
In our example, \textbf{the parser will apply the multiplication first} (because applying addition first would lead the parser in a state where $(A$ and $B)$
are atoms). Let's consider the case where we use this rule:

\begin{tabular}{lll}
  \varstyle{Atom} & $\rightarrow$ & ( \varstyle{Atom} ) \\
\end{tabular}

The parser will apply it and end up with $A + B$ as an atom. Since $A + B$ is \textbf{not a terminal}, this produces an error. Because $A + B$ is an arithmetic
expression itself, we must not regard it as an atom. Let's correct the rule:

\begin{tabular}{lll}
  \varstyle{Atom} & $\rightarrow$ & ( \varstyle{ExprArith-p0} ) \\
\end{tabular}

Let's check the derivation of $(A + B) * C$ (and skip some steps for making it more concise):

\begin{tabular}{ll}
  & \varstyle{ExprArith-p0}  \\
  $\rightarrow$ & \varstyle{ExprArith-p1} \\
  $\rightarrow$ & \varstyle{ExprArith-p1} \varstyle{Op-p1} \varstyle{Atom} \\
  $\rightarrow$ & \varstyle{Atom} * \varstyle{Atom} \\
  $\rightarrow$ & ( \varstyle{ExprArith-p0} ) * [VarName] \\
  $\rightarrow$ & ( \varstyle{ExprArith-p0} \varstyle{Op-p0} \varstyle{ExprArith-p1} ) * [VarName] \\
  $\rightarrow$ & ( \varstyle{ExprArith-p1} + \varstyle{ExprArith-p1} ) * [VarName] \\
  $\rightarrow$ & ( \varstyle{Atom} + \varstyle{Atom} ) * [VarName] \\
  $\rightarrow$ & ( [VarName] + [VarName] ) * [VarName] \\
\end{tabular}

We obtain the desired outcome. Let's add rule \varstyle{Atom} $\rightarrow$ ( \varstyle{ExprArith-p0} ) to the grammar.

\subsubsection{Arithmetic operators}

Let's summarize all the changes we did to the grammar:

\begin{tabular}{lll}
  \varstyle{SimpleCond} & $\rightarrow$ & \varstyle{ExprArith-p0} \varstyle{Comp} \varstyle{ExprArith-p0} \\
  \varstyle{ExprArith-p0} & $\rightarrow$ & \varstyle{ExprArith-p0} \varstyle{Op-p0} \varstyle{ExprArith-p1} \\
  & $\rightarrow$ & \varstyle{ExprArith-p1} \\
  \varstyle{ExprArith-p1} & $\rightarrow$ & \varstyle{ExprArith-p1} \varstyle{Op-p1} \varstyle{Atom} \\
  & $\rightarrow$ & \varstyle{Atom} \\
  \varstyle{Atom} & $\rightarrow$ & [VarName] \\
  & $\rightarrow$ & [Number] \\
  & $\rightarrow$ & ( \varstyle{ExprArith-p0} ) \\
  & $\rightarrow$ & - \varstyle{Atom} \\
  \varstyle{Op-p0} & $\rightarrow$ & + \\
  & $\rightarrow$ & - \\
  \varstyle{Op-p1} & $\rightarrow$ & * \\
  & $\rightarrow$ & / \\
\end{tabular}

\subsubsection{Logical operators}

We apply the same reasoning we did for arithmetic operators.
The changes to apply to deal with priorities of operators \{or, and, not\} \textbf{are similar to the changes we made} to take the priorities of operators
\{+, *, -\} into account. After repeating our analysis, we obtain the following new rules for logical operators:

\begin{tabular}{lll}
  \varstyle{Cond-p0} & $\rightarrow$ & \varstyle{Cond-p0} or \varstyle{Cond-p1} \\
  & $\rightarrow$ & \varstyle{Cond-p1} \\
  \varstyle{Cond-p1} & $\rightarrow$ & \varstyle{Cond-p1} and \varstyle{Cond-p2} \\
  & $\rightarrow$ & \varstyle{Cond-p2} \\
  \varstyle{Cond-p2} & $\rightarrow$ & not \varstyle{SimpleCond} \\
  & $\rightarrow$ & \varstyle{SimpleCond} \\
\end{tabular}

\subsection{Operator associativity}

\todo{Dire que les regles qu'on a ajoutees sont recursives à gauche, donc associatives à gauche, pour ce qui est des parentheses, l'associativite n'a pas de sens. Enfin pour le - unaire, montrer que c'est bon aussi}

\section{Removing left-recursion and applying factorization}

\subsection{Left-recursion removal}

\todo{Dis-donc Jamy, c'est quoi la recursivite a gauche ? Faudrait pas lire les notes de Geeraerts sur ca ? Expliquer pourquoi cet algo marche}

<A> → <A>a
On ajoute:
<A> → <A-i> <A-j>
<A-j> → epsilon
et, pour chacune règle
<A> → <A>b
on change par
<A-j> → b
et, pour chaque règle
<A> → c
on change par
<A-i> → c

\subsection{Left-factoring}

\todo{Pareil, expliquer}

\begin{tabular}{lll}
  \varstyle{If} & $\rightarrow$ & if \varstyle{Cond} then \varstyle{Code} \varstyle{IfTail} \\
  \varstyle{IfTail} & $\rightarrow$ & endif \\
  & $\rightarrow$ & else \varstyle{Code} endif \\
  \varstyle{For} & $\rightarrow$ & for [VarName] from \varstyle{ExprArith} \varstyle{ForTail} \\
  \varstyle{ForTail} & $\rightarrow$ & \varstyle{ExprArith} to \varstyle{ExprArith} do \varstyle{Code} done \\
  & $\rightarrow$ & \varstyle{ExprArith} do \varstyle{Code} done \\
\end{tabular}

\section{Resulting grammar}

\newcounter{Rule}
\newsavebox{\varbox}
\begin{longtable}{
    >{\sffamily[\stepcounter{Rule}\theRule}r<{]}
    l
    @{ $\rightarrow$ } >{\ttfamily}l<{\ttfamily}
  }
  & \varstyle{Program} & begin \varstyle{Code} end \\
  & \varstyle{Code} & epsilon \\
  &  & \varstyle{InstList} \\
  & \varstyle{Instruction} & \varstyle{Assign} \\
  &  & \varstyle{If} \\
  &  & \varstyle{While} \\
  &  & \varstyle{For} \\
  &  & \varstyle{Print} \\
  &  & \varstyle{Read} \\
  & \varstyle{Assign} & [VarName] := \varstyle{ExprArith-p0} \\
  & \varstyle{ExprArith-p0-j} & \varstyle{Op-p0} \varstyle{ExprArith-p1} \\
  & \varstyle{ExprArith-p0-i} & \varstyle{ExprArith-p1} \\
  & \varstyle{ExprArith-p1-j} & \varstyle{Op-p1} \varstyle{Atom} \\
  & \varstyle{ExprArith-p1-i} & \varstyle{Atom} \\
  & \varstyle{Atom} & [VarName] \\
  &  & [Number] \\
  &  & ( \varstyle{ExprArith-p0} ) \\
  &  & - \varstyle{Atom} \\
  & \varstyle{Op-p0} & + \\
  &  & - \\
  & \varstyle{Op-p1} & * \\
  &  & / \\
  & \varstyle{Cond-p0-j} & or \varstyle{Cond-p1} \\
  & \varstyle{Cond-p0-i} & \varstyle{Cond-p1} \\
  & \varstyle{Cond-p1-j} & and \varstyle{Cond-p2} \\
  & \varstyle{Cond-p1-i} & \varstyle{Cond-p2} \\
  & \varstyle{Cond-p2} & not \varstyle{SimpleCond} \\
  &  & \varstyle{SimpleCond} \\
  & \varstyle{SimpleCond} & \varstyle{ExprArith-p0} \varstyle{Comp} \varstyle{ExprArith-p0} \\
  & \varstyle{Comp} & = \\
  &  & >= \\
  &  & > \\
  &  & <= \\
  &  & < \\
  &  & <> \\
  & \varstyle{While} & while \varstyle{Cond-p0} do \varstyle{Code} done \\
  & \varstyle{Print} & print ( [VarName] ) \\
  & \varstyle{Read} & read ( [VarName] ) \\
  & \varstyle{If} & if \varstyle{Cond-p0} then \varstyle{Code} \varstyle{If-Tail} \\
  & \varstyle{If-Tail} & else \varstyle{Code} endif \\
  &  & endif \\
  & \varstyle{For} & for [VarName] from \varstyle{ExprArith-p0} \varstyle{For-Tail} \\
  & \varstyle{For-Tail} & by \varstyle{ExprArith-p0} to \varstyle{ExprArith-p0} do \varstyle{Code} done \\
  &  & to \varstyle{ExprArith-p0} do \varstyle{Code} done \\
  & \varstyle{InstList} & \varstyle{Instruction} \varstyle{InstList-Tail} \\
  & \varstyle{InstList-Tail} & ; \varstyle{InstList} \\
  &  & epsilon \\
  & \varstyle{ExprArith-p1} & \varstyle{ExprArith-p1-i} \varstyle{ExprArith-p1-j} \\
  & \varstyle{ExprArith-p0-j} & epsilon \\
  & \varstyle{Cond-p1} & \varstyle{Cond-p1-i} \varstyle{Cond-p1-j} \\
  & \varstyle{ExprArith-p0} & \varstyle{ExprArith-p0-i} \varstyle{ExprArith-p0-j} \\
  & \varstyle{Cond-p0-j} & epsilon \\
  & \varstyle{Cond-p0} & \varstyle{Cond-p0-i} \varstyle{Cond-p0-j} \\
  & \varstyle{ExprArith-p1-j} & epsilon \\
  & \varstyle{Cond-p1-j} & epsilon \\
\end{longtable}