\documentclass[12pt]{report}

\usepackage[english]{babel}
\usepackage{times}
\usepackage{fullpage}
\usepackage[bottom]{footmisc}
\usepackage{chngcntr}
\usepackage{etoolbox}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{geometry}
\usepackage{calrsfs}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage{titlesec}
\usepackage{amssymb} 
\usepackage{makecell}
\usepackage{color}
\usepackage{enumerate}
\usepackage{array}
\usepackage{longtable}

\newcommand\todo[1]{\textcolor{red}{TODO: #1}}

\titleformat{\chapter}{\normalfont\huge}{\thechapter.}{20pt}{\huge}

\title{Introduction to language theory and compiling \\ Project -- Part 2}
\author{Antoine Passemiers \\ Alexis Reynouard}

\pagestyle{plain}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em plus0.5em minus0.3em}

\pagenumbering{Roman}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
\setcounter{chapter}{0}
\pagenumbering{arabic}

\newcommand{\varstyle}[1]{\notblank{#1}{\textsf{$<$#1$>$}}{}}

\begin{document}
\maketitle
\tableofcontents
\thispagestyle{empty}
\pagebreak
\setcounter{page}{1}
\clearpage

\chapter{Transforming Imp grammar}

This part of the project consists in implementing a $LL(k)$ parser for the Imp programming language. A $LL(k)$ parser is a recursive descent parser composed of:

\begin{itemize}
\item An \textbf{input buffer}, containing $k$ input tokens. Since we are designing a $LL(1)$ parser only, the latter only considers one token at a time to decide how to grow the syntactic tree.
\item A \textbf{stack} containing the set of remaining terminals and non-terminals to process.
\item An \textbf{action table}, mapping the front of the stack and the current token to the corresponding rule. Every time a rule is retrieved from the action table, the top of the stack is replaced by the sequence of symbols to the right of the current rule.
\end{itemize}

One is not able to construct an action table if the given grammar is not $LL(1)$. For that purpose, we were asked to modify the grammar in such a way
that it becomes possible to determine the $first^1$ and $follow^1$ sets of each symbol of the grammar. More specifically,
we must remove useless variables, unproductive rules, take into account operators priority and associativity, remove left-recursion and finally left-factor the grammar.

The order in which one processes these steps in crucial: if one tries to add rules with respect to the operators priority, one may encounter problems due
to unproductive rules. In addition to that, the method we were suggested to use to deal with associativity and priority actually introduces new left-recursive
rules. That is the reason why the left-recursion removal must be applied after using this method.

\section{Remark about symbols}
In this report, we will refer to symbols as \textbf{grammar symbols} or simply \textbf{symbols}. To speak about symbols for the lexer, we will refer to it as \textbf{lexical symbols}. The distinction is crucial because the lexer and the parser are based on different types of automata.
The deterministic automaton (used by the lexer) can only process \textbf{characters} while the pushdown automaton (used by the parser) takes
\textbf{tokens as input}. A token is an instance of a lexical unit and consists in a sequence of characters. Plus, tokens are generated by the lexer and
used as input to the parser. By nature, they use \textbf{different alphabets}.

Also, we will refer to sequences of grammar symbols as \textbf{words}. They latter are different from lexical words, which represent tokens.


\section{Removing useless rules and symbols}

A \textbf{useless symbol} is a symbol that is either unproductive (terminals are productive by nature, so they are not considered when we talk about productivity) or unreachable. A \textbf{useless rule} can only be an unproductive rule, which means that it contains
unproductive variables. A variable is called unproductive if none of its derivations yields anything. An unreachable symbol is a symbol that cannot be derived
from the start grammar symbol. Let's summarize: a rule is useless if it is unproductive, a terminal is useless if it is unreachable, and a variable is useless if it is either unreachable or unproductive. This step of the project consists in removing those symbols and rules, when they are useless.

\subsection{Unreachable symbols}

Unreachable symbols are symbols that cannot be accessed using composed rules from grammar $G$.

\begin{tabular}{|l p{35em}|} \hline
   i & $V_i$ \\ \hline
  0 & $\{Program\}$ \\ \hline
  1 & $V_0 \cup \{Code\}$ \\ \hline
  2 & $V_1 \cup \{IntList\}$ \\ \hline
  3 & $V_2 \cup \{Instruction\}$ \\ \hline
  4 & $V_3 \cup \{Assign, If, While, For, Print, Read\}$ \\ \hline
  5 & $V_4 \cup \{ExprArithm, Cond\}$ \\ \hline
  6 & $V_5 \cup \{Op, BinOp, SimpleCond\}$ \\ \hline
  7 & $V_6 \cup \{Comp\}$ \\ \hline
  8 & $V_7$ \\ \hline
\end{tabular}

All variables are accessible.

\subsection{Unproductive variables}

A rule is productive if all symbols of its right-hand part are productive. Because terminals are always productive, we must only look for
productive variables. The intuition is that a variable is unproductive if none of its derivations yields anything. In other words, it is impossible to find a \textbf{finite} word such that it can be derived from this variable. Typically, this happens when the variable is recursive. For example:
\begin{equation}
  \begin{split}
    \varstyle{ExprArith-p1} \rightarrow \varstyle{ExprArth-p1} + \varstyle{ExprArith-p2}
   \end{split}
\end{equation}

This rule, \textbf{all by itself} (with no other rule including \varstyle{ExprArithmP1} as left-hand variable), is unproductive.
Indeed, the derivation requires an infinite number of steps to reach $ + $ \varstyle{ExprArithP2}, which results in an infinite word of variables.
To be productive, this word must be composed of \textbf{terminals}.
More formally, a productive rule $A \rightarrow \alpha$ must be such that its left-hand productive variable yields a finite sequence of terminals:
\begin{equation}
  \begin{split}
    A \Rightarrow_{G}^{*} w \text{ where } w \in T^{*}
  \end{split}
\end{equation}

To remove unproductive rules, we had to remove unproductive variables first. The easiest way to proceed is to enumerate the productive variables.
We did it as follows:
\begin{itemize}
  \item Initialize the set of productive symbols as the set of terminals, because we know that terminals are productive by nature. Indeed, 
  a string composed of a \textbf{finite number of terminals} is finite itself.
  \item Every time a rule of the form $A \rightarrow \alpha$ is found, where $\alpha$ is a string composed of productive symbols, we add its left-hand 
  variable to the set of productive symbols. The reason is that a string composed of strings of terminals are also finite. Using an inductive reasoning, 
  one can notice that this intuition holds for as many recursion levels as needed.
  \item We stop after we have explored all rules without discovering new productive variables.
\end{itemize}
This yields the following table:

\begin{tabular}{|l p{35em}|} \hline
   i & $V_i$ \\ \hline
  0 & $T$ \\ \hline
  1 & $V_0 \cup \{Code, ExprArithm, Op, BinOp, Comp, Print, Read\}$ \\ \hline
  2 & $V_1 \cup \{Program, Instruction, Assign, For, SimpleCond\}$ \\ \hline
  3 & $V_2 \cup \{IntList, Cond\}$ \\ \hline
  4 & $V_3 \cup \{While, If\}$ \\ \hline
  5 & $V_4$ \\ \hline
\end{tabular}

At the end, we get that the set contains all grammar symbols. As consequence, all variables are productive. To validate this result, we implemented
an unproductive-rule removal algorithm and got the same result.

\section{Removing ambiguity}

\subsection{Operator priority}

\begin{tabular}{lll}
  \varstyle{CondP1} & $\rightarrow$ & \varstyle{CondP1} and \varstyle{CondP2} \\
  & $\rightarrow$ & \varstyle{CondP2} \\
  \varstyle{CondP2} & $\rightarrow$ & \varstyle{CondP2} or \varstyle{CondP3} \\
  & $\rightarrow$ & \varstyle{CondP3} \\
  \varstyle{CondP3} & $\rightarrow$ & not \varstyle{SimpleCond} \\
  & $\rightarrow$ & \varstyle{SimpleCond} \\
\end{tabular}

\begin{tabular}{lll}
  \varstyle{Assign} & $\rightarrow$ & [VarName] := \varstyle{ExprArith-p0} \\
  \varstyle{ExprArith-p2} & $\rightarrow$ & [VarName] \\
  & $\rightarrow$ & [Number] \\
  & $\rightarrow$ & ( \varstyle{ExprArith-p2} \\

  \varstyle{SimpleCond} & $\rightarrow$ & \varstyle{ExprArithmP1} \varstyle{Comp} \varstyle{ExprArithP1} \\
  \varstyle{ExprArithP1} & $\rightarrow$ & \varstyle{ExprArithP1} + \varstyle{ExprArithP2} \\
  & $\rightarrow$ & \varstyle{ExprArithP1} - \varstyle{ExprArithP2} \\
  & $\rightarrow$ & \varstyle{ExprArithP2} \\
  \varstyle{ExprArithP2} & $\rightarrow$ & \varstyle{ExprArithP2} * \varstyle{ExprArithP3} \\
  & $\rightarrow$ & \varstyle{ExprArithP2} / \varstyle{ExprArithP3} \\
  & $\rightarrow$ & \varstyle{ExprArithP3} \\
  \varstyle{ExprArithP3} & $\rightarrow$ & [VarName] \\
  & $\rightarrow$ & [number] \\
  & $\rightarrow$ & ( \varstyle{ExprArithP3} ) \\
  & $\rightarrow$ & - \varstyle{ExprArithP3} \\
\end{tabular}

\subsection{Operator associativity}

\section{Removing left-recursion and applying factorization}

\subsection{Left-recursion removal}

<A> → <A>a
On ajoute:
<A> → <A-i> <A-j>
<A-j> → epsilon
et, pour chacune règle
<A> → <A>b
on change par
<A-j> → b
et, pour chaque règle
<A> → c
on change par
<A-i> → c

\subsection{Left-factoring}

\begin{tabular}{lll}
  \varstyle{If} & $\rightarrow$ & if \varstyle{Cond} then \varstyle{Code} \varstyle{IfTail} \\
  \varstyle{IfTail} & $\rightarrow$ & endif \\
  & $\rightarrow$ & else \varstyle{Code} endif \\
  \varstyle{For} & $\rightarrow$ & for [VarName] from \varstyle{ExprArith} \varstyle{ForTail} \\
  \varstyle{ForTail} & $\rightarrow$ & \varstyle{ExprArith} to \varstyle{ExprArith} do \varstyle{Code} done \\
  & $\rightarrow$ & \varstyle{ExprArith} do \varstyle{Code} done \\
\end{tabular}

\section{Resulting grammar}

\newcounter{Rule}
\newsavebox{\varbox}
\begin{longtable}{
    >{\sffamily[\stepcounter{Rule}\theRule}r<{]}
    l
    @{ $\rightarrow$ } >{\ttfamily}l<{\ttfamily}
  }
  & \varstyle{Program} & begin \varstyle{Code} end \\
  & \varstyle{Code} & epsilon \\
  &  & \varstyle{InstList} \\
  & \varstyle{Instruction} & \varstyle{Assign} \\
  &  & \varstyle{If} \\
  &  & \varstyle{While} \\
  &  & \varstyle{For} \\
  &  & \varstyle{Print} \\
  &  & \varstyle{Read} \\
  & \varstyle{Assign} & [VarName] := \varstyle{ExprArith-p0} \\
  & \varstyle{ExprArith-p2} & [VarName] \\
  &  & [Number] \\
  &  & ( \varstyle{ExprArith-p2} ) \\
  &  & - \varstyle{ExprArith-p2} \\
  & \varstyle{ExprArith-p0-j} & \varstyle{Op-p0} \varstyle{ExprArith-p1} \\
  & \varstyle{ExprArith-p0-i} & \varstyle{ExprArith-p1} \\
  & \varstyle{ExprArith-p1-j} & \varstyle{Op-p1} \varstyle{ExprArith-p2} \\
  & \varstyle{ExprArith-p1-i} & \varstyle{ExprArith-p2} \\
  & \varstyle{Op-p0} & + \\
  &  & - \\
  & \varstyle{Op-p1} & * \\
  &  & / \\
  & \varstyle{Cond-p0-j} & \varstyle{BinOp-p0} \varstyle{Cond-p1} \\
  & \varstyle{Cond-p0-i} & \varstyle{Cond-p1} \\
  & \varstyle{Cond-p1-j} & \varstyle{BinOp-p1} \varstyle{Cond-p2} \\
  & \varstyle{Cond-p1-i} & \varstyle{Cond-p2} \\
  & \varstyle{Cond-p2} & not \varstyle{SimpleCond} \\
  &  & \varstyle{SimpleCond} \\
  & \varstyle{SimpleCond} & \varstyle{ExprArith-p0} \varstyle{Comp} \varstyle{ExprArith-p0} \\
  & \varstyle{BinOp-p1} & and \\
  & \varstyle{BinOp-p0} & or \\
  & \varstyle{Comp} & = \\
  &  & >= \\
  &  & > \\
  &  & <= \\
  &  & < \\
  &  & <> \\
  & \varstyle{While} & while \varstyle{Cond-p0} do \varstyle{Code} done \\
  & \varstyle{Print} & print ( [VarName] ) \\
  & \varstyle{Read} & read ( [VarName] ) \\
  & \varstyle{If} & if \varstyle{Cond-p0} then \varstyle{Code} \varstyle{If-Tail} \\
  & \varstyle{If-Tail} & else \varstyle{Code} endif \\
  &  & endif \\
  & \varstyle{For} & for [VarName] from \varstyle{ExprArith-p0} \varstyle{For-Tail} \\
  & \varstyle{For-Tail} & by \varstyle{ExprArith-p0} to \varstyle{ExprArith-p0} do \varstyle{Code} done \\
  &  & to \varstyle{ExprArith-p0} do \varstyle{Code} done \\
  & \varstyle{InstList} & \varstyle{Instruction} \varstyle{InstList-Tail} \\
  & \varstyle{InstList-Tail} & ; \varstyle{InstList} \\
  &  & epsilon \\
  & \varstyle{ExprArith-p1} & \varstyle{ExprArith-p1-i} \varstyle{ExprArith-p1-j} \\
  & \varstyle{ExprArith-p0-j} & epsilon \\
  & \varstyle{Cond-p1} & \varstyle{Cond-p1-i} \varstyle{Cond-p1-j} \\
  & \varstyle{ExprArith-p0} & \varstyle{ExprArith-p0-i} \varstyle{ExprArith-p0-j} \\
  & \varstyle{Cond-p0-j} & epsilon \\
  & \varstyle{Cond-p0} & \varstyle{Cond-p0-i} \varstyle{Cond-p0-j} \\
  & \varstyle{ExprArith-p1-j} & epsilon \\
  & \varstyle{Cond-p1-j} & epsilon \\
\end{longtable}



\chapter{Implementation}

\section{How to use the parser}

Arguments :
	(1) [OPTIONS] --ru <grammar file> -o <grammar output file>
	(2) [OPTIONS] --ll <grammar file> -o <grammar output file>
	(3) [OPTIONS] --at <ll1 unambiguous grammar file>
	(4) [OPTIONS] <ll1 unambiguous grammar file> <code> -o <latex output file>


\end{document}
